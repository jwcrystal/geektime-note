# 棧 Stack

## 如何理解棧？

FILO(First In Last Out)，先進後出，後進先出，為典型棧結構。

從棧的操作特性來看，為一種操作受限的線性表，只能在一段插入刪除數據。

> 當某個數據集合只涉及在一端插入和刪除數據，並且滿足後進先出、先進後出的特性，這時我們就應該首選棧這種數據結構。

## 如何實現棧？

- 順序棧：用數組實現
- 鏈式棧：用鏈表實現

下方為 java、go 實現的順序棧：
```java
// 基於數組實現的順序棧
public class ArrayStack {
  private String[] items;  // 數組
  private int count;       // 棧中元素個數
  private int n;           //棧的大小

  // 初始化數組，申請一個大小為 n 的數組空間
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入棧操作
  public boolean push(String item) {
    // 數組空間不夠了，直接返回 false，入棧失敗。
    if (count == n) return false;
    // 將 item 放到下標為 count 的位置，並且 count 加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出棧操作
  public String pop() {
    // 棧為空，則直接返回null
    if (count == 0) return null;
    // 返回下標為count-1的數組元素，並且棧中元素個數count減一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```
```go
# 基於切片實現順序棧
type T int

type Stack struct {
   sync.RWMutex
   array []T
}

func NewStack() *Stack {
   stack := &Stack{}
   stack.array = []T{}
   return stack
}

// Push 將 t 加入棧頂
func (s *Stack) push(t T) {
    s.Lock()
    s.array.append(s.array, t)
    s.Unlock()
} 

// Pop 拿取棧頂的元素
func (s *Stack) pop() (*T, error) {
    if len(s.array) == 0 {
        return nil, fmt.Errorf("stack empty")
    }
    s.Lock()
    item := s.array[len(s.array) - 1]
    s.array = s.array[:item]
    s.Unlock()
    return &item, nil
}
```

在入棧和出棧過程中，只需要一兩個臨時變量存儲空間，所以空間複雜度是 O(1);不管是順序棧還是鏈式棧，入棧、出棧只涉及棧頂個別數據的操作，所以時間複雜度都是 O(1)。

## 支持動態擴容的順序棧

只需要底層數據結構採用支援動態擴容的輸組即可。

對於出棧來說，沒什麼區別，因為**不會涉及內存的重新申請和數據搬移**；但對於入棧操作來說，最好情況時間複雜度是 O(1)，最壞情況時間複雜度是 O(n)。

![](media/16819555091953/16822373441932.jpg)

![](media/16819555091953/16822375404739.jpg)

上圖方便討論，進行假設：

- 只有入棧，沒有出棧
- 每次都是 simple push，所以入棧時間複雜度為 O(1)
- 當空間不夠時，重新申請前數組兩倍空間

均攤時間複雜度一般都等於最好情況時間複雜度。因為在大部分情況下，入棧操作的時間複雜度 O 都是 O(1)，只有在個別時刻才會退化為 O(n)，所以把耗時多的入棧操作的時間均攤到其他入棧操作上，平均情況下的耗時就接近 O(1)。

## 棧在函數調用中的應用

操作系統給每個線程分配了一塊獨立的內存空間，**這塊內存被組織成棧這種結構, 用來存儲函數調用時的臨時變量**。每進入一個函數，就會將臨時變量作為一個棧幀入棧，當被調用函數執行完成，返回之後，將這個函數對應的棧幀出棧。

下圖為 add() 函數在函數調用棧的操作
![](media/16819555091953/16822378752524.jpg)

## 棧在表達式求值的應用

實際上，編譯器就是兩個棧的應用實現。一個保存數據的棧，另一保存操作符的棧。

如果比運算符棧頂元素的優先級高，就將當前運算符壓入棧；如果比運算符棧頂元素的優先級低或者相同，從運算符棧中取棧頂運算符，從操作數棧的棧頂取 2 個操作數，然後進行計算，再把計算完的結果壓入操作數棧，繼續比較。

下圖為數值計算的求值過程
![](media/16819555091953/16822379829497.jpg)

## 棧在括號匹配中的應用

用棧來保存未匹配的左括號，從左到右依次掃描字符串。
當掃描到左括號時，則將其壓入棧中；當掃描到右括號時，從棧頂取出一個左括號。如果能夠匹配，比如 "(" 跟 ")" 匹配，"[" 跟 "]"匹配，"{" 跟 "}"匹配，則繼續掃描剩下的字符串。如果掃描的過程中，遇到不能配對的右括號，或者棧中沒有數據，則說明為非法格式；如果全掃描完，棧為空即為合法格式。

## 如何實現瀏覽器的前進、後退功能

如同上面有提到的。其實，一樣用兩個棧即可處理。
一個棧放前進的網站，另一放後退的網站。當首次進入網站，會先把網站放入前進棧，當退出網站時候，從前進棧取出並放入後退棧即可。

## 小結

棧是一種操作受限的數據結構，只支持入棧和出棧操作。後進先出是它最大的特點。棧既可以通過數組實現，也可以通過鏈表來實現。不管基於數組還是鏈表，入棧、出棧的時間複雜度都為 O(1)。

為什麼要用棧來保存臨時變量？
> 函數調用經常嵌套，嵌套越深的函數越先被執行，剛好符合棧的特點。

JVM 的棧和前面提到的棧，有什麼差異？
> 內存中的堆棧和數據結構堆棧不是一個概念，可以說內存中的堆棧是真實存在的物理區，數據結構中的堆棧是抽象的數據存儲結構。 
> 內存空間在邏輯上分為三部分：代碼區、靜態數據區和動態數據區，動態數據區又分為棧區和堆區。 代碼區：存儲方法體的二進制代碼。高級調度（作業調度）、中級調度（內存調度）、低級調度（進程調度）。
> 棧區：存儲運行方法的形參、局部變量、返回值。由系統自動分配和回收。
> 堆區：new 一個對象的引用或地址存儲在棧區，指向該對象存儲在堆區中的真實數據。

文章 May D1 學習筆記，內容來源於極客時間 [《數據結構與算法之美》](https://time.geekbang.org/column/article/41222)
